<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>



  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type" />


  
  
  <title>SVGKit Overview</title>
</head>


<body>



<h1>SVGKit<br />



</h1>



<h2>Introduction</h2>



Lowest level. &nbsp;Create a new SVG at runtime.
&nbsp;Load SVG data from a URL. Conveniently handle quirks of three
ways SVG can be included in browsers: object, embed, and inline. Handle
differnet browsers and different SVG engines. &nbsp;Has convenience
functions for DOM manipulation ala MochiKit. It manages the objects:
HTMLElement, SVGDocument, SVGElement. &nbsp;Basic intaractive event
handling like scroll, zoom, object select and manipulate (maybe this
should go in SVGEvent.js)<br />


<br />


Once you have an SVGKit object, adding content is simple.
&nbsp;Inspired by MochiKit DOM, there is an all-caps function for every
tag defined in the SVG spec.<br />


<br />


svg.append(CIRCLE( {'cx':50, 'cy':50, 'r':20, 'fill':'purple', 'fill-opacity':.3) );<br />


<h2>Overview of Code</h2>


There is a single object SVGKit. &nbsp;You instantiate one for each SVG
you want access too. &nbsp;You can use its constructor to grab an
existing SVG, load an SVG from a file, or create a blank SVG to draw
into. &nbsp;The goal of the code is to grab the svg element and be able
to manipulate it independent of the browser/plugin and the technique
used to include the SVG on the page. &nbsp;In many browsers this is
just not possible for some or all methods.<br />



<h2>Overview of JavaScript access to SVG</h2>



There are several different ways for JavaScript to access SVG content.
The there are three major DOM elements, each of which has a corresponding member in a SVGKit object.<br />



<ul>



  <li><span class="objectBox objectBox-string"></span><span class="objectBox objectBox-string"></span>SVGDocument
(this.svgDocument)&nbsp; has methods like createElement,
getElementById, and getElementsByTagName. If the SVG is imbeded in a
document or the JavaScript code lives in the SVG file, this will just
be document, otherwise you have to get it from the HTML element that
the SVG is sitting in.</li>



  <li>SVGSVGElement (this.svgElement)&nbsp; has the width and
height, graphical content elements in childNodes, and the more graphical methods
like suspendRedraw, and createSVGTransform.</li>



  <li><span class="objectBox objectBox-string">HTMLElement
    </span>(this.<span class="objectBox objectBox-string">htmlElement)
which is the container that contains the SVG (object, embed, iframe,
svg)&nbsp; in an HTML document. &nbsp;</span>If the SVG
is imbeded in a document directly, this will just be the same as
svgElement. <span class="objectBox objectBox-string">An
object and embed element also has a width and height which may be
different that the SVGElement's, in which case you'll probably get a
scroll bar.</span></li>



</ul>


Here's a summary of the most common ways to get access to the all
important SVGSVGElement in JavaScript. &nbsp;Different browsers
impliment different methods to varying degrees.<br />


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">


  <tbody>


    <tr>


      <td></td>


      <td><span class="objectBox objectBox-string">htmlElement</span></td>


      <td>svgDocument</td>


      <td>svgElement</td>


    </tr>


    <tr>


      <td>inline</td>


      <td>the svg tag<br />


      </td>


      <td>document or svgElement.ownerDocument</td>


      <td>same as htmlElement</td>


    </tr>


    <tr>


      <td>embed</td>


      <td>the embed tag</td>


      <td>htmlElement.getSVGDocument()</td>


      <td>svgDocument.rootElement or svgDocument.documentElement</td>


    </tr>


    <tr>


      <td>object</td>


      <td>the object tag</td>


      <td>htmlElement.contentDocument</td>


      <td>svgDocument.rootElement or svgDocument.documentElement</td>


    </tr>


    <tr>


      <td>iframe</td>


      <td>the iframe tag</td>


      <td>can never access</td>


      <td>can never access</td>


    </tr>


    <tr>


      <td>inside svg</td>


      <td>can you access?</td>


      <td>document</td>


      <td>svgDocument.rootElement</td>


    </tr>


  
  
  </tbody>
</table>




<h2>Constructors</h2>



<ul>



</ul>



<ul>


  <li>SVGKit() -- For JavaScript included in an SVG</li>


  <li>SVGKit(node) -- Already have an HTML element</li>


  <li>SVGKit(id) -- Have the id for an HTML element (if your id ends in
.svg, pass in the node instead because strings ending in .svg will be
treated as&nbsp;filenames.)</li>


  <li>SVGKit(filename, id, type, width, height) -- Create a new HTML element that references filename (must end in .svg)</li>


  <li>SVGKit(width, height, id, type) -- Create a new SVG from scratch
with width, height, and id. &nbsp;type is 'inline' 'embed' or 'object'</li>


</ul>


For embed or object: It won't necessarily be ready when the constructor
returns so all real graphical manipulation has to be registerd as a
callback to whenReady (these interface <span style="font-style: italic;">force</span>
you to register an onload callback to allow it to load in the
background.) &nbsp;If you are creating a new SVG, what really happens
is an embed/object tag is created referencing an svg file with no
graphical content. This means you have to manage a URI
to&nbsp;empty.svg. &nbsp;Another issue with embed/object is that if
they get hidden (for example the div they're contained in becomes
invisible) the browser will just dump the DOM and all of your hard
work. I'm thinking about registering an onhide event which saves the
xml and then restores it on load..<br />


<br />


For inline: &nbsp;Creating a new SVG is as simple as creating a DOM
element. &nbsp;Loading an SVG from a file is difficult because an xml
loader must be used and the SVG extracted and properly recognized as
SVG content so you have access to the graphical DOM methods and your
content shows up. If you load an inline SVG from a file, you're going
to have to register your graphical manipulation with whenReady<br />


<h2>Overview of Functionality</h2>


<ul>


  <li>Content Manipulation: createSVGDOM, append, createUniqueID, getDefs, suspendRedraw, deleteContent, etc.</li>


  <li>Transformations: rotate, translate, scale. &nbsp;These can be
applied to any element and do some rudimentary optimization. (If you
translate the same element twice, combine them into a single
translation.) &nbsp;I could suck all transformations into a single
transformation matrix (like Inkscape), and while the would be efficient
to render, it would be ugly to read.</li>


  <li>Output: toXML and emitXML.</li>


</ul>

<h2>To Do</h2>


<ul>
  <li>Server-side conversion to svg, pdf, ps, png, jpeg</li>
</ul>
<h2>Possible Applications</h2>


<ul>

  <li>GUI Widgets to make a web app more like a desktop app (or a whole desktop environment), perhaps using GNOME SVG widgets.</li>

  <li>Web-based X-Windows client (some of this more appropriately done
with Canvas, or perhaps embeded Canvases within SVG.) &nbsp;X commands
would have to be tunneled through HTTP on the web server because of the
JavaScript network security restrictions.</li>

  <li>Drawing or CAD program</li>

  <li>Plotting/Graphing/Charting</li>

</ul>


</body>
</html>
